

* Namespaces

- All namespaces always automatically refer to all public symbols in the standard library "pile.core".

** Loading

The first time a namespace is loaded the runtime will inspect the classpath to find a corresponding source file, if any. For example, loading the namespace 'a.b.c' will cause the runtime to load the classpath file 'a/b/c.pile'. This file is loaded *atomically* by the first thread to attempt to load that namespace. All threads arriving before the loading is complete will wait, and thus will always see a fully constructed namespace if it has been loaded via this mechanism.

** Importing Symbols

There are several functions that can assist in importing symbols from other namespaces or define references to java classes

*** import

The import function defines a symbol of the short name of a class with the value of the class instance object. This is mainly used with Java classes.

#+begin_src clojure :eval no
;; The following two lines are equivalent
(import java.lang.Integer)
(def ^:final Integer java.lang.Integer)
#+end_src

TODO More examples

*** refer

The refer macro will bind symbols in this namespace as references to symbols in another namespace.

#+begin_src clojure :eval no
pile.repl> (ns a.b)
a.b> (def v 12)
*0: #'a.b/v
a.b> (ns pile.repl)
pile.repl> (refer a.b)
pile.repl> (defn print-v [] (prn v))
*1: #'pile.repl/print-v
pile.repl> (print-v)
12
pile.repl> (ns a.b)
a.b> (def v 55)
*2: #'a.b/v
a.b> (ns pile.repl)
pile.repl> (print-v)
55
#+end_src

*** require

Loads a namespace with some options.

#+begin_src clojure :eval no
;; Calling a fully qualified function
(pile.core.string/join ...)
;; Create short name for namespace
(require '[pile.core.string :as s])
(s/join ...)
;; Directly refer to specific functions in require
(require '[pile.core.string :refer [join]])
(join ...)
;; Directly refer to a function but rename our reference to it
(require '[pile.core.string :refer [join] :rename {join string-join}])
(string-join ...)
#+end_src


* Function Features
** Closures

When creating a function it is possible to reference values in the enclosing scope outside of the function. This creates a closure.

#+begin_src clojure :eval no
pile.repl> (defn plus [a] (fn [b] (+ a b)))
*0: #'pile.repl/plus
pile.repl> (def plus-two (plus 2))
*1: #'pile.repl/plus-two
pile.repl> (plus-two 10)
*2: 12
#+end_src

** Varargs

Functions support vararg definitions by adding an ampersand before the final argument.

#+begin_src clojure :eval no
pile.repl> (defn print-args [a & remaining] (prn "First arg, a=" a) (prn "Remaining args=" remaining))
*6: #'pile.repl/print-args
pile.repl> (print-args "first" "second" "third" "last")
First arg, a=first
Remaining args=(second third last)
;; 44
#+end_src

** Calling with apply

It is sometimes useful to call functions using without having to manually unpack the data structures
into method arguments. This is accomplished with the 'apply' function which accepts a function and
any number of arguments with the final argument being something sequence-able. 

#+begin_src clojure :eval no
;; All produce 44
(apply + [40 4])
(apply + 40 [4])
(apply + 40 4 [])

#+end_src

* More Sequences

Many operations take a sequence as one of their arguments and return a new sequence:
- (map _function_ _sequence_)
  Computes a function on each element.
- (mapcat _function_ _sequence_)
  Computes a function on each element expecting a sequence result, which is flattened.
- (reduce _function_ _initvalue_ _sequence_)
  Reduces the sequence starting with the initial value.
- (take _n_ _sequence_)
  Creates a new sequence with at most _n_ elements
- (take-while _function_ _sequence_)
  Creates a new sequences while the function predicate returns true
- (drop _n_ _sequence_)
  Drops the first _n_ elements in the sequence, returning a sequence of the remaining elements, if any.
- (drop-while _function_ _sequence_)
  Drops the elements until the predicate returns false, returning a sequence of the remaining elements, if any.
- (interpose _delim_ _sequence_)
  Creates a new sequence which inserts the delim character between each element in the sequence
- (enumerate _sequence_)
  Creates pairs of values with an increasing index.


Sequences can be destructured by specifying a vector of bindings where you would normally use an argument or local variable:

#+begin_src clojure :eval no
(defn desc [prefix [first-arg second-arg]] (prn prefix " first=" first-arg ", second=" second-arg))
(desc "before" ["the-first-arg" 12])
;; before, first=the-first-arg, second=12

(defn desc-two [prefix args] (let [[first-arg second-arg] args] (prn prefix " first=" first-arg ", second=" second-arg)))
(desc-two "before" ["the-first-arg" 12])
;; before, first=the-first-arg, second=12
#+end_src


